#pragma kernel TrashcoreYCbCr
#pragma kernel TrashcoreCronch
#pragma kernel TrashcoreDct
#pragma kernel TrashcoreCrunch
#pragma kernel TrashcoreIdct

// Create a RenderTexture with enableRandomWrite flag and set it
RWTexture2D<float4> Result;
Texture2D<float4> Input;
SamplerState samplerInput; // auto-gemerated by unity if name is texture plus "sampler" prefix 

float Resolution_x;
float Resolution_y;
int crunch;

float4 RGBToYCbCr(float4 rgba)
{
    float Y  = 0.299 * rgba.r + 0.587 * rgba.g + 0.114 * rgba.b;
    float Cb = (rgba.b - Y) * 0.564 + 0.5;
    float Cr = (rgba.r - Y) * 0.713 + 0.5;
    return float4(Cr, Y, Cb, 1.0); // not typical order but is closest to rgb while debugging
}

[numthreads(8,8,1)]
void TrashcoreYCbCr (uint3 id : SV_DispatchThreadID)
{
    float x = id.x / Resolution_x;
    float y = id.y / Resolution_y;
    float4 inputColor = Input.SampleLevel(samplerInput, float2(x, y), 0);
    Result[id.xy] = RGBToYCbCr(inputColor);
}

[numthreads(8,8,1)]
void TrashcoreCronch (uint3 id : SV_DispatchThreadID)
{
    float4 tap_00 = Input.Load(int3(    2 * id.x,     2 * id.y, 0));
    float4 tap_01 = Input.Load(int3(1 + 2 * id.x,     2 * id.y, 0));
    float4 tap_02 = Input.Load(int3(    2 * id.x, 1 + 2 * id.y, 0));
    float4 tap_03 = Input.Load(int3(1 + 2 * id.x, 1 + 2 * id.y, 0));
    Result[id.xy] = 0.25 * (tap_00 + tap_01 + tap_02 + tap_03);
}

[numthreads(8,8,1)]
void TrashcoreDct (uint3 id : SV_DispatchThreadID)
{
    // id.x and y represent the DCT block indices (not pixels!)
    int2 dct_origin = int2(id.x * 8, id.y * 8);
    for (int s = 0; s < 8; s++) // s and t are in frequency space (output)
    {
        for (int t = 0; t < 8; t++)
        {
            float4 sum = 0.0;
            for (int u = 0; u < 8; u++)  // u and v are in texture space (input
            {
                for (int v = 0; v < 8; v++)
                {
                    float4 pixelValue = Input[int2(dct_origin.x + u, dct_origin.y + v)];
                    float cos_x = cos(((2 * u + 1) * s * 3.14159265359) / 16.0);
                    float cos_y = cos(((2 * v + 1) * t * 3.14159265359) / 16.0);
                    sum += pixelValue * cos_x * cos_y;
                }
            }
            float C_s = (s == 0) ? sqrt(0.5) : 1.0;
            float C_t = (t == 0) ? sqrt(0.5) : 1.0;
            Result[int2(dct_origin.x + s, dct_origin.y + t)] = 0.25 * C_s * C_t * sum;
        }
    }
}

[numthreads(8,8,1)]
void TrashcoreCrunch (uint3 id : SV_DispatchThreadID)
{
    float4 inputValue = Input.Load(int3(id.x, id.y, 0));

    // Reduce total number of posterization levels as one gets further from DCT block origin
    int2 dct_offset = int2(id.x % 8, id.y % 8);
    float manhattanDistance = dct_offset.x + dct_offset.y; // oh yeah cuz we nasty like that
    float frequency_falloff = lerp(1.0, 8.0, (manhattanDistance - 5.0) / (16.0 - 5.0));

    // actual jpeg compression uses a different formula but lets exeriment a little
    float f_crunch = float(crunch);
    Result[id.xy] = floor(inputValue * f_crunch / frequency_falloff) / f_crunch * frequency_falloff;
}

[numthreads(8,8,1)]
void TrashcoreIdct (uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = Input.Load(int3(id.x, id.y, 0));
}